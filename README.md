# Blotto in Dash Project

This **Blotto in Dash** project is a small basic exercise exploring the fundamentals of Dash to create a functional Blotto game against the machine (random generation using Python's `random` module).

## Basic Gameplay:

The game works by interacting with the following components:

- **Selecting the rules** to play by in the radio items component.
- **Selecting the number of battlefields** to be played (3 to 6) using a dropdown component.
- **Selecting the number of rounds** to be played in the match (Optional). The round match must be activated by clicking the button that says “Start match”. You can cancel or finish a match by clicking the same button. If it is not activated, you are in free mode, and all rounds will be counted in the victories table until you start a match.
- **Allocate the amount of resources** in the sliders (each slider represents a battlefield). The game works with a constant of 100 resources to be allocated across all battlefileds, regardless of how many battlefields were chosen.
- **Press the submit button** when you are happy with the allocations to simulate the round. The submit button will be disabled if a match round is activated and the last round has already been played (click finish game to reset victories table and start over in free mode).
- **Check results in graphics:**
  - **Distribution per battlefield** shows how many resources were allocated by both the player and AI in the different battlefields.
  - **Map** shows a map of the territories that were won by the player in blue, by the AI in red, or tied in grey.
- **Check the victories table** to see how many rounds both the player and the AI have won and how many ties have occurred.

Each round is won by the number of battlefields won, regardless of the total amount of resources allocated.

## Brief Explanation of the Code:

- The code starts by setting some constants and variables for databases and particular elements.
- The layout sets all the HTML and DCC elements seen on the page and the DCC Stores to store variables while the app is running:
  - The last allocations submitted by the player and last generated by the AI.
  - The status of the match to know if it is active or not (true or false).
  - The number of rounds played to know when to finish the match (if activated).
  
- There are 8 callbacks to control the different processes as follows:
  1. Controls which text is displayed according to the rules chosen in the radio items.
  2. Changes the children of the match button depending on whether it is activated or not. It shows the corresponding message in an HTML div and disables the submit button if a match is activated and the last round has already been played.
  3. Changes the number of sliders according to the number selected in the "number of battlefields" dropdown.
  4. Reads and indicates if the amount of resources indicated in sliders exceeds the total resources (100).
  5. Changes the status of the match to activate it or deactivate it.
  6. Stores the data submitted by the player in the sliders and generates ai allocations calling a function from (`reglas.py`) when the submit button is clicked.
  7. Validates the player's data to ensure it follows the rules calling a function from (`reglas.py`), restarts the victories data frame used for the victories table if the rounds match is started or canceled, determines who won more battlefields, updates rounds played (if necessary), updates the victories table, and uses data frames to build the graphics.
  8. Updates styles for radio items to highlight the selected one and for the victories table so it highlights the one with the most victories (highlights both if tied in victories).

The app also works with another file (`reglas.py`) that contains two functions used in the app:

1. `def get_ai_allocations(num_battlefields, rule)`: Generates random allocations that follow the rules selected in the radio items element.
2. `def validate_player_allocs(player_allocs, rule, TOTAL_RESOURCES)`: Validates player allocations to ensure they follow the selected rules and builds an appropriate message if they don't.